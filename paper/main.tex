%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}

\acmConference[OOPSLA'19]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2018}{New York, NY, USA}
\acmYear{2019}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\setcopyright{none}
\bibliographystyle{ACM-Reference-Format}

\usepackage{pervasives}

\begin{document}

\title[]{\sys{}: Safe High-level Synthesis}

\author{Rachit Nigam}
\affiliation{\institution{Cornell University}\country{U.S.A.}}
\email{rnigam@cs.cornell.edu}
\author{Sachille Atapattu}
\affiliation{\institution{Cornell University}\country{U.S.A.} }
\email{first2.last2@inst2b.org}
\author{Theodore Bauer}
\affiliation{\institution{Cornell University}\country{U.S.A.} }
\email{first2.last2@inst2b.org}
\author{Adrian Sampson}
\affiliation{\institution{Cornell University}\country{U.S.A.} }
\email{first2.last2@inst2b.org}


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
With the end of Moore's law in sight, FPGAs and reconfigurable hardware are
gaining prominence in a variety of computationally heavy domains such as
machine learning. However, writing hardware programs remains challenging
because (1) the abstractions provided by hardware design languages (HDLs) is
too low level and (2) high-level synthesis (HLS) tools, which promise to
raise the level of abstraction, provide ad hoc mechanisms on top of unsafe
languages like C and C++ and repurpose wildly inefficient EDA flows. Towards
the goal of creating a safe and expressive abstractions for hardware
programming, we present \sys{}, a programming language that exposes the
unique resource constraints in hardware and guarantees hardware
realizability. This is in contrast to contemporary HLS tools which try, and
fail, at transparently compiling C/C++ programs to hardware. HLS tools often
add inefficient hardware in order to compile these programs and make it
significantly harder to understand the performance characteristics of the
generated hardware. Instead of hiding hardware constraints, \sys{} exposes
them to the developer and simplifies reasoning about them.
\end{abstract}

%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code

%% Keywords
%% comma separated list
\keywords{Type Systems, High-level synthesis, FPGAs}  %% \keywords are mandatory in final camera-ready submission

%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

\section{Introduction}
Introduction goes here.

\section{Design Principles}
\subsection{Cost Model}
\subsection{Type Safety}
\subsection{Equivalance to Von Neumann Semantics}

\section{Language Constructs}
\subsection{Linear banked arrays and logical time}
\subsection{Unrolling loops and relation to cost model}
\subsection{Combiners and Reductions}
In \sys{}, each \sysfor{} can have an optional \syscombine{} block that specifies
code that runs after one unrolled iteration of the loop. In \cref{lst:combine},
\lstinline|v| behaves as a normal variable in the \sysfor{}-loop body, but
turns into a memory with $5$ banks. The \lstinline|+=| operator used in the
\syscombine{} block creates an adder chain that adds all elements of \lstinline|v|
and store the result in \lstinline|sum|.

A \textit{Reducer} is a function that takes \sysmem{N}{N} and returns a single
value. \sys{} provides several default reducers: \lstinline|+=|, \lstinline|*=|,
\lstinline|-=|, and \lstinline|/=|. As with \sysunroll{} and \sysbank{},
\syscombine{} blocks can be safely removed to get sequential semantics.

\begin{lstlisting}[caption={\sysfor{} loop with a \syscombine{} block}, label={lst:combine}, frame=single]
  let sum = 0;
  for (let i = 0..10) unroll 5 {
    let v = a[i];
  } combine {
    sum += v;
  }
\end{lstlisting}
\subsection{Views}
\subsection{Pipelining}
\subsection{Polymorphism}

\section{Language Formalism}
\subsection{Syntax and semantics}
\subsection{Type rules}
\subsection{Soundness and type safety}

\section{Evaluation}
\subsection{Implementation}
We've implemented a compiler for \sys{} in \sysloc{} of Scala. The compiler
takes in \sys{} programs, type checks them, and generates C code which is then
compiled to hardware designs using the Xilinx C HLS compiler [CITE].
\subsection{Experimental setup}
\subsection{Baseline against CPUs}
\subsection{Usability}
\subsubsection{Annotation burden}
\subsubsection{Ruling out errors}

\section{Related Works}

\subsection{Halide}
Halide~\cite{halide} is a domain specific language (DSL) that provides high-level constructs for writing image processing
programs. It separates the high-level structure of an algorithm from the
performance trade-offs such as caching, loop fusion, etc.\ and automatically to
infer optimal schedules for them. \sys{} on the other provides lower-level constructs
that expose the resource constraints imposed by the hardware. \sys{} can act as a
compilation target for compiling DSLs like Halide to hardware.

There have also been efforts to compile Halide to hardware~\cite{halide-hls} using ad-hoc
restrictions on the language. \sys{} provides a more principled approach for
exposing these ad-hoc constraints.

\subsection{Spatial}
Spatial~\cite{spatial} is a domain specific programming language embedded in Scala
and compiles to Chisel. It strives to provide abstract but explicit hardware programs,
introducing several language features for extracting parallelism out of accelerators. Spatial
differs from \sys{} in that it abstracts the resources used to implement memories, allowing
the compiler to automatically find resource utilization and memory access latency optimizations.
\sys{} instead exposes these resources at the language level, and type-checks them for hardware
realizability. Thus, \sys{} provides more fine-tune control and safety guarantees. This makes
\sys{} a compelling target for higher-level tools that focus more on automated design space
exploration.

% \rn{Similar question. Why not build higher level primitives like spatial and leave the safety checking and compilation to the compiler?}
% \xxx[as]{And a similar answer: automation like represents an implicit trade-off. You get to not worry about the details, but then the details are hidden from you. So if you find you're getting back hardware out of Spatial, you don't see it manifest in the code and you have no recourse to fix it. Instead, we do the hard work to make all the details visible at the language level. This should be better for (a) experts who want exacting control over the hardware they generate, and (b) eventually building higher-level tools that enhance automation on top of this abstraction.}

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}

%% Bibliography
\bibliography{./bib/venues,./bib/papers}

%% Appendix
\appendix
\section{Appendix}

Text of appendix

\end{document}
